# ForkJoin
ForKJoin主要采用的**分而治之**的思想。本质是一个用于并行任务的框架，可以把大的任务拆分成若干小任务，最终汇总到一起得到总的计算结果返回。对于一个任务而言，只有当它所有的子任务完成之后，它才能够被执行。 该模式包含两个关键操作：Fork（分解）和Join（合并）。
ForkJoin框架是从jdk1.7中引入的新特性,它同ThreadPoolExecutor一样，也实现了Executor和ExecutorService接口。
ForkJoin使用了一个无限队列来保存需要执行的任务，而线程数是通过构造参数传入，如果没传入则会根据当前计算机可用CPU数来设置默认线程数。
```
使用参考 ForkJoinDemo
```
## Fork/Join框架工作原理
### 任务分解：Fork
1. 当一个任务执行时，Fork/Join框架首先检查任务是否比临界值小
2. 如果任务小于临界值，直接完成任务，或者将其分配给可用的工作线程
3. 如果任务超过了临界值则需要进一步分解，Fork/Join框架将任务分解为更小的子任务
4. 分解过程通过创建新的任务实例来完成，每个子任务负责处理原始任务的一个子区域部分

### 任务执行
1. 子任务在不同的线程中执行
2. Fork/Join框架使用线程池（ForkJoinPool）来管理任务，线程池中的线程负责任务的执行
3. 如果线程池中有空闲线程，分解的子任务可以立即分配给他们执行。否则任务进入等待状态直到有可用线程。

### 任务合并：Join
1， 当一个任务执行完成后，将他的结果返回给父任务
2. 父任务可以通过调用join方法等待子任务完成。并获取子任务的结果，如果有多个子任务则需要等待所有子任务返回，合并他们的结果为最终结果，
3. 合并结果通常是递归形式，直到所有子任务完成，将结果汇总后返回

## 工作窃取算法
工作窃取（Work Stealing）是一种并行编程中的任务调度策略，是用于提高任务并行性和负载均衡的。
再处理一个大任务时，可以把它分割成若干互补干扰的小任务，ForkJoinPool中的每个线程都有自己的工作队列，当线程处理完自己线程队列中的任务后时，发现其他线程队列里还有任务在等待处理，就会窃取其他任务里的任务来执行，这是他们会访问一个队列，这个队列通常是双端队列，被窃取的任务线程永远从头部获取任务，窃取人物的线程永远从尾部来获取任务。
工作窃取模型的一个关键点是每个工作线程都有自己的本地任务队列，以避免不必要的线程间同步开销。当工作线程窃取任务时，它们通常从其他线程的任务队列的末尾开始窃取，这可以减少竞争和同步的可能性。// 使用双端队列的数据结构
### 窃取算法的优缺点
这种策略对于解决以下两个问题非常有效：

1. 负载均衡：在并行计算中，任务的大小和复杂度可能不均匀，导致某些工作线程完成任务较早，而其他工作线程仍然在执行。通过工作窃取，空闲的工作线程可以从繁忙的线程队列中窃取任务来执行，以达到负载均衡的效果。
2. 避免线程闲置：传统的任务分配模型中，当一个线程执行完自己的任务后，可能会处于等待状态，直到有新任务可用。而在工作窃取模型中，线程可以主动获取任务，避免了线程的闲置时间，提高了并行性和效率。

优点：充分利用线程的并行计算能力，减少线程间的竞争。
缺点：某些情况下还是会发生竞争，比如双端队列中只有一个任务，就会消耗更多的资源，比如多创建一个线程和多个双端队列。
## 使用场景

Fork/Join 框架适用于以下几个应用场景：

1. 递归任务：当一个问题可以递归地分解为更小的子问题时，Fork/Join 框架可以很好地处理。每个子问题可以并行地执行，然后通过 Join 操作将结果合并。
2. 分而治之（Divide and Conquer）算法：分而治之算法通常将问题分解为多个子问题，并通过合并子问题的结果来解决原始问题。Fork/Join 框架可以自动处理分解和合并的过程，使得并行化的实现更加方便。
3. 数据并行任务：当一个任务可以被分割为多个独立的数据块进行处理时，Fork/Join 框架可以有效地将任务分配给不同的处理器进行并行计算。每个处理器可以独立地处理自己分配到的数据块，并通过合并操作将最终结果组合起来。
4. 递归式的搜索或遍历算法：Fork/Join 框架在处理递归式的搜索或遍历算法时非常有用。例如，在树结构中的深度优先搜索或广度优先搜索算法中，可以使用 Fork/Join 框架将搜索任务分解为多个子任务，并行地进行搜索。

需要注意的是，Fork/Join 框架**最适合处理计算密集型的任务**，其中任务的执行时间较长，可以充分利用并行性提高计算效率。对于I/O密集型任务或需要频繁进行I/O操作的任务，Fork/Join 框架可能不是最佳选择，因为它的主要优势在于处理并行计算。

## 与ThreadPool的区别
首先，使用ForkJoinPool能够使用数量有限的线程来完成非常多的具有**父子关系的任务**，比如使用4个线程来完成超过200万个任务。但是，使用ThreadPoolExecutor时，是不可能完成的，因为ThreadPoolExecutor中的Thread无法选择优先执行子任务，需要完成200万个具有父子关系的任务时，也需要200万个线程，很显然这是不可行的，也是很不合理的！！
ThreadPoolExecutor中的线程无法向任务队列中再添加一个任务并在等待该任务完成之后再继续执行。而使用ForkJoinPool就能够解决这个问题，它就能够让其中的线程创建新的任务，并挂起当前的任务，此时线程就能够从队列中选择子任务执行。


